# -*- coding: utf-8 -*-
"""server_hathak.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BgP2ZX7bGjBiONLgOsqEIh6576Sk7x1J
"""

# -*- coding: utf-8 -*-
# Telegram Auto-Poster Bot for Forum Topics (Haraj Al-An'am)
# Runtime: python-telegram-bot==21.4
# Entrypoint: python main.py

import os, sqlite3, time, hashlib, asyncio, logging
from typing import Dict, Any, List
from datetime import datetime, timedelta, timezone

from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup,
    ReplyKeyboardMarkup, ReplyKeyboardRemove, InputMediaPhoto
)
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    ConversationHandler, ContextTypes, filters
)

# ============ Logging ============
logging.basicConfig(
    format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    level=logging.INFO
)
logger = logging.getLogger("haraj-bot")

# ============ Env / Config ============
BOT_TOKEN = os.environ.get("BOT_TOKEN")  # Ø¶Ø¹Ù‡ ÙÙŠ Secrets Ø¹Ù„Ù‰ Railway
FORUM_CHAT_ID = int(os.environ.get("FORUM_CHAT_ID", "-1002509382400"))
FORUM_USERNAME = os.environ.get("FORUM_USERNAME", "hat_hak_hirag")
OWNER_ID = int(os.environ.get("OWNER_ID", "0"))
RATE_LIMIT_HOURS = int(os.environ.get("RATE_LIMIT_HOURS", "6"))

THREAD_IDS: Dict[str, int] = {
    "Ø§Ù„Ø¥Ø¨Ù„": 2,
    "Ø§Ù„Ø£ØºÙ†Ø§Ù…": 3,
    "Ø§Ù„Ø®ÙŠÙˆÙ„": 4,
    "Ø§Ù„Ø·ÙŠÙˆØ±": 5,
    "Ù…Ø³ØªÙ„Ø²Ù…Ø§Øª Ø§Ù„Ø­Ù„Ø§Ù„": 6,
    "Ù†ØµØ§Ø¦Ø­ ÙˆØ¥Ø±Ø´Ø§Ø¯ Ø¨ÙŠØ·Ø±ÙŠ": 7,
    "Ø§Ù„Ø´Ø­Ù† ÙˆØ§Ù„Ø®Ø¯Ù…Ø§Øª Ø§Ù„Ù„ÙˆØ¬Ø³ØªÙŠØ©": 8,
    "Ø¹Ù‚ÙˆØ¯ Ø§Ù„Ø¨ÙŠØ¹ ÙˆØ§Ù„ÙˆØ³Ø§Ø·Ø©": 9,
    "Ø¥Ø¹Ù„Ø§Ù†Ø§Øª ÙˆØ¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ø¥Ø¯Ø§Ø±Ø©": 10,
}

SECTION, AGE, COUNT, PRICE, LOCATION, PHOTOS, CONTACT = range(7)

DB_PATH = os.environ.get("DB_PATH", "ads.db")

# ============ DB ============
def db_init():
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("""CREATE TABLE IF NOT EXISTS users (
        user_id INTEGER PRIMARY KEY,
        last_post_ts INTEGER DEFAULT 0
    )""")
    c.execute("""CREATE TABLE IF NOT EXISTS posted_ads (
        ad_hash TEXT,
        user_id INTEGER,
        created_ts INTEGER,
        PRIMARY KEY (ad_hash, user_id)
    )""")
    conn.commit()
    conn.close()

def get_last_post_ts(user_id: int) -> int:
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute("SELECT last_post_ts FROM users WHERE user_id=?", (user_id,))
    row = c.fetchone()
    conn.close()
    return row[0] if row else 0

def set_last_post_ts(user_id: int, ts: int):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "INSERT INTO users(user_id,last_post_ts) VALUES(?,?) "
        "ON CONFLICT(user_id) DO UPDATE SET last_post_ts=excluded.last_post_ts",
        (user_id, ts),
    )
    conn.commit()
    conn.close()

def ad_recently_posted(user_id: int, ad_hash: str, window_hours: int = RATE_LIMIT_HOURS) -> bool:
    cutoff = int(time.time()) - window_hours * 3600
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "SELECT 1 FROM posted_ads WHERE user_id=? AND ad_hash=? AND created_ts>=?",
        (user_id, ad_hash, cutoff),
    )
    row = c.fetchone()
    conn.close()
    return bool(row)

def store_posted_ad(user_id: int, ad_hash: str):
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute(
        "INSERT OR REPLACE INTO posted_ads(ad_hash,user_id,created_ts) VALUES(?,?,?)",
        (ad_hash, user_id, int(time.time()))
    )
    conn.commit()
    conn.close()

# ============ Helpers ============
def fmt(val: str) -> str:
    return val if val else "â€” (ØºÙŠØ± Ù…Ø­Ø¯Ø¯)"

def make_ad_hash(section: str, age: str, count: str, price: str, location: str) -> str:
    base = f"{section}|{(age or '').strip()}|{(count or '').strip()}|{(price or '').strip()}|{(location or '').strip()}"
    return hashlib.sha256(base.encode("utf-8")).hexdigest()[:24]

def seconds_to_hhmm(ss: int) -> str:
    hh = ss // 3600
    mm = (ss % 3600) // 60
    return f"{hh} Ø³Ø§Ø¹Ø© Ùˆ {mm} Ø¯Ù‚ÙŠÙ‚Ø©"

def build_ad_text(bot_username: str, data: Dict[str, Any]) -> str:
    section = data.get("section") or "â€”"
    header = f"ğŸ“¢ Ù„Ù„Ø¥Ø¹Ù„Ø§Ù† ÙˆØ§Ù„Ù†Ø´Ø± ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¨ÙˆØª: @{bot_username}\n"
    promo  = f"ğŸŸ¢ Ø§Ù„Ø¢Ù†: Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯ ÙÙŠ Ù‚Ø³Ù… {section}\n"

    body = (
        f"ğŸª Ø§Ù„Ù‚Ø³Ù…: {fmt(data.get('section'))}\n"
        f"ğŸ“† Ø§Ù„Ø¹Ù…Ø±: {fmt(data.get('age'))}\n"
        f"ğŸ”¢ Ø§Ù„Ø¹Ø¯Ø¯: {fmt(data.get('count'))}\n"
        f"ğŸ’° Ø§Ù„Ø³Ø¹Ø±: {fmt(data.get('price'))}\n"
        f"ğŸ“ Ø§Ù„Ù…ÙˆÙ‚Ø¹: {fmt(data.get('location'))}\n"
    )

    missing = []
    for k in ("age", "count", "price", "location"):
        if not data.get(k):
            missing.append(k)

    warn = "\nâš ï¸ Ø¨Ø¹Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù†Ø§Ù‚ØµØ© â€“ Ù„Ù„ØªÙØ§ØµÙŠÙ„ ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹" if missing else ""
    return header + "\n" + promo + "\n" + body + warn

def get_bot_username(context: ContextTypes.DEFAULT_TYPE) -> str:
    uname = context.bot_data.get("bot_username")
    if uname:
        return uname
    return "YOUR_BOT_USERNAME"

def build_contact_button(update: Update, contact_un: str | None):
    """
    ÙŠØ¨Ù†ÙŠ Ø²Ø± ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹. Ù„Ùˆ Ù…ÙÙŠØ´ username Ù…Ø­Ø¯Ø¯ØŒ ÙŠØ­Ø§ÙˆÙ„ ÙŠØ³ØªØ®Ø¯Ù… Username ØµØ§Ø­Ø¨ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù†.
    Ù„Ùˆ Ù…ÙÙŠØ´ Ø¨Ø±Ø¶Ù‡ØŒ ÙŠØ±Ø¬Ù‘Ø¹ None Ø¨Ø¯ÙˆÙ† Ø£Ø²Ø±Ø§Ø±.
    """
    username = None
    if contact_un:
        username = contact_un.lstrip("@")
    elif update.effective_user and update.effective_user.username:
        username = update.effective_user.username

    if not username:
        return None

    url = f"https://t.me/{username}"
    kb = InlineKeyboardMarkup([[InlineKeyboardButton("ØªÙˆØ§ØµÙ„ Ù…Ø¹ Ø§Ù„Ø¨Ø§Ø¦Ø¹", url=url)]])
    return kb

# ============ Commands ============
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    me = await context.bot.get_me()
    context.bot_data["bot_username"] = me.username
    kb = ReplyKeyboardMarkup([["Ø¨Ø¯Ø¡ Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯"]], resize_keyboard=True)
    text = (
        "Ø­ÙŠØ§Ùƒ Ø§Ù„Ù„Ù‡ ğŸ‘‹\n"
        "Ø¹Ø´Ø§Ù† ØªÙ†Ø²Ù„ Ø¥Ø¹Ù„Ø§Ù†Ùƒ: Ø§Ø¶ØºØ· Â«Ø¨Ø¯Ø¡ Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯Â» Ø£Ùˆ Ø§ÙƒØªØ¨ /announce\n\n"
        f"â€¢ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† Ø§Ù„ÙˆØ§Ø­Ø¯ Ù„ÙƒÙ„ Ø¨Ø§Ø¦Ø¹ ÙƒÙ„ {RATE_LIMIT_HOURS} Ø³Ø§Ø¹Ø§Øª\n"
        "â€¢ Ø§Ù„Ù†Ø´Ø± ØªÙ„Ù‚Ø§Ø¦ÙŠ ÙÙŠ Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…Ù†Ø§Ø³Ø¨\n"
        "â€¢ Ù„Ùˆ Ù†Ø³ÙŠØª Ø¨ÙŠØ§Ù†Ø§ØªØŒ Ù‡Ù†Ù†Ø²Ù„ Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† ÙˆÙ…Ø¹Ø§Ù‡ ØªÙ†Ø¨ÙŠÙ‡ Ø¨Ø³ÙŠØ·"
    )
    await update.effective_message.reply_text(text, reply_markup=kb)

async def topicid(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = update.effective_message
    tid = getattr(msg, "message_thread_id", None)
    chat_id = update.effective_chat.id
    await msg.reply_text(f"chat_id: {chat_id}\nmessage_thread_id: {tid}")

async def kill(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if OWNER_ID and update.effective_user and update.effective_user.id != OWNER_ID:
        return await update.message.reply_text("ØºÙŠØ± Ù…ØµØ±Ø­.")
    context.application.bot_data["__STOP_FLAG__"] = True
    await update.message.reply_text("Ø¬Ø§Ø±Ù Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¨ÙˆØªâ€¦")
    await context.application.stop()
    await context.application.shutdown()

# ============ Conversation ============
async def announce_entry(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    last_ts = get_last_post_ts(user_id)
    now = int(time.time())
    wait_s = last_ts + RATE_LIMIT_HOURS*3600 - now
    if wait_s > 0:
        await update.effective_message.reply_text(
            f"Ø¹Ø°Ø±Ù‹Ø§ Ù„Ø§ ÙŠÙ…ÙƒÙ†Ùƒ Ù†Ø´Ø± Ø§Ø¹Ù„Ø§Ù†Ø§Øª Ø§Ù„Ø§ ÙƒÙ„ {RATE_LIMIT_HOURS} Ø³Ø§Ø¹Ø§Øª ØŒ ØªÙ‚Ø¯Ø± ØªÙ†Ø²Ù„ Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯ Ø¨Ø¹Ø¯: {seconds_to_hhmm(wait_s)}"
        )
        return ConversationHandler.END

    context.user_data.clear()
    context.user_data["photos"] = []

    sections = list(THREAD_IDS.keys())
    rows = [sections[i:i+3] for i in range(0, len(sections), 3)]
    kb = ReplyKeyboardMarkup(rows + [["Ø¥Ù„ØºØ§Ø¡"]], resize_keyboard=True, one_time_keyboard=True)
    await update.effective_message.reply_text("Ø§Ø®ØªØ± Ø§Ù„Ù‚Ø³Ù… Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ø¥Ø¹Ù„Ø§Ù†Ùƒ:", reply_markup=kb)
    return SECTION

async def set_section(update: Update, context: ContextTypes.DEFAULT_TYPE):
    section = update.effective_message.text.strip()
    if section not in THREAD_IDS:
        await update.effective_message.reply_text("Ø§Ø®ØªÙŠØ§Ø± ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ø®ØªØ± Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±.", reply_markup=ReplyKeyboardRemove())
        return ConversationHandler.END
    context.user_data["section"] = section
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ù…Ø± (Ù…Ø«Ø§Ù„: 3 Ø³Ù†ÙˆØ§Øª). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return AGE

async def set_age(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["age"] = update.effective_message.text.strip()
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ (Ù…Ø«Ø§Ù„: 15). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return COUNT

async def skip_age(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["age"] = ""
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ø¹Ø¯Ø¯ (Ù…Ø«Ø§Ù„: 15). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return COUNT

async def set_count(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["count"] = update.effective_message.text.strip()
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¹Ø± (Ù…Ø«Ø§Ù„: 950 Ø±ÙŠØ§Ù„). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return PRICE

async def skip_count(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["count"] = ""
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ø³Ø¹Ø± (Ù…Ø«Ø§Ù„: 950 Ø±ÙŠØ§Ù„). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return PRICE

async def set_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["price"] = update.effective_message.text.strip()
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Ù…Ø«Ø§Ù„: Ø§Ù„Ø±ÙŠØ§Ø¶). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return LOCATION

async def skip_price(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["price"] = ""
    await update.effective_message.reply_text("Ø§ÙƒØªØ¨ Ø§Ù„Ù…ÙˆÙ‚Ø¹ (Ù…Ø«Ø§Ù„: Ø§Ù„Ø±ÙŠØ§Ø¶). Ø§ÙƒØªØ¨ /skip Ù„Ùˆ Ù…Ø´ Ø¹Ø§ÙŠØ² ØªØ­Ø¯Ø¯.")
    return LOCATION

async def set_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["location"] = update.effective_message.text.strip()
    await update.effective_message.reply_text(
        "Ø£Ø±Ø³Ù„ ØµÙˆØ± Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† (ØµÙˆØ±Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±ØŒ Ø¨Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10). Ù„Ù…Ø§ ØªØ®Ù„Øµ Ø§ÙƒØªØ¨ /done. Ø£Ùˆ Ø§ÙƒØªØ¨ /skip Ù„ØªØ®Ø·ÙŠ Ø§Ù„ØµÙˆØ±."
    )
    return PHOTOS

async def skip_location(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["location"] = ""
    await update.effective_message.reply_text(
        "Ø£Ø±Ø³Ù„ ØµÙˆØ± Ø§Ù„Ø¥Ø¹Ù„Ø§Ù† (ØµÙˆØ±Ø© Ø£Ùˆ Ø£ÙƒØ«Ø±ØŒ Ø¨Ø­Ø¯ Ø£Ù‚ØµÙ‰ 10). Ù„Ù…Ø§ ØªØ®Ù„Øµ Ø§ÙƒØªØ¨ /done. Ø£Ùˆ Ø§ÙƒØªØ¨ /skip Ù„ØªØ®Ø·ÙŠ Ø§Ù„ØµÙˆØ±."
    )
    return PHOTOS

async def add_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if "photos" not in context.user_data:
        context.user_data["photos"] = []
    phs: List[str] = context.user_data["photos"]

    if len(phs) >= 10:
        await update.effective_message.reply_text("ÙˆØµÙ„Øª Ù„Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ (10 ØµÙˆØ±). Ø§ÙƒØªØ¨ /done Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©.")
        return PHOTOS

    photo = update.message.photo[-1]
    phs.append(photo.file_id)
    await update.effective_message.reply_text(f"ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… ØµÙˆØ±Ø© ({len(phs)}/10). Ø£Ø±Ø³Ù„ Ø§Ù„Ù…Ø²ÙŠØ¯ Ø£Ùˆ Ø§ÙƒØªØ¨ /done.")
    return PHOTOS

async def skip_photos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["photos"] = []
    default_un = update.effective_user.username
    hint = f"ÙŠÙˆØ²Ø±Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: @{default_un}" if default_un else "Ù…Ø§ Ø¹Ù†Ø¯Ùƒ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…."
    await update.effective_message.reply_text(f"Ø§ÙƒØªØ¨ ÙˆØ³ÙŠÙ„Ø© Ø§Ù„ØªÙˆØ§ØµÙ„ (Username ÙÙ‚Ø·). {hint} Ø§ÙƒØªØ¨ /skip Ù„Ùˆ ØªØ¹ØªÙ…Ø¯ ÙŠÙˆØ²Ø±Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø£Ùˆ Ø±Ø§Ø¨Ø· Ù…Ø¨Ø§Ø´Ø±.")
    return CONTACT

async def done_photos(update: Update, context: ContextTypes.DEFAULT_TYPE):
    default_un = update.effective_user.username
    hint = f"ÙŠÙˆØ²Ø±Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ: @{default_un}" if default_un else "Ù…Ø§ Ø¹Ù†Ø¯Ùƒ ÙŠÙˆØ²Ø±Ù†ÙŠÙ…."
    await update.effective_message.reply_text(f"Ø§ÙƒØªØ¨ ÙˆØ³ÙŠÙ„Ø© Ø§Ù„ØªÙˆØ§ØµÙ„ (Username ÙÙ‚Ø·). {hint} Ø§ÙƒØªØ¨ /skip Ù„Ùˆ ØªØ¹ØªÙ…Ø¯ ÙŠÙˆØ²Ø±Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø£Ùˆ Ø±Ø§Ø¨Ø· Ù…Ø¨Ø§Ø´Ø±.")
    return CONTACT

async def set_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["contact"] = update.effective_message.text.strip().lstrip("@")
    return await finalize_post(update, context)

async def skip_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data["contact"] = ""
    return await finalize_post(update, context)

async def finalize_post(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    data = context.user_data

    ad_hash = make_ad_hash(
        data.get("section",""),
        data.get("age",""),
        data.get("count",""),
        data.get("price",""),
        data.get("location",""),
    )
    if ad_recently_posted(user.id, ad_hash, RATE_LIMIT_HOURS):
        await update.effective_message.reply_text("ÙŠØ¨Ø¯Ùˆ Ø¥Ù†Ùƒ Ù†Ø²Ù„Øª Ø¥Ø¹Ù„Ø§Ù† Ù…Ø´Ø§Ø¨Ù‡ Ù…Ø¤Ø®Ø±Ù‹Ø§. Ø­Ø§ÙˆÙ„ Ù„Ø§Ø­Ù‚Ù‹Ø§.")
        return ConversationHandler.END

    section = data.get("section")
    thread_id = THREAD_IDS.get(section)
    if not thread_id:
        await update.effective_message.reply_text("Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù‚Ø³Ù…. Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©.")
        return ConversationHandler.END

    bot_username = get_bot_username(context)
    ad_text = build_ad_text(bot_username, data)
    contact_kb = build_contact_button(update, data.get("contact"))

    photos = data.get("photos", [])
    sent_msg = None

    try:
        if photos and len(photos) >= 2:
            media = [InputMediaPhoto(pid) for pid in photos[:10]]
            await context.bot.send_media_group(
                chat_id=FORUM_CHAT_ID,
                message_thread_id=thread_id,
                media=media,
            )
            sent_msg = await context.bot.send_message(
                chat_id=FORUM_CHAT_ID,
                message_thread_id=thread_id,
                text=ad_text,
                reply_markup=contact_kb,
            )
        elif photos and len(photos) == 1:
            sent_msg = await context.bot.send_photo(
                chat_id=FORUM_CHAT_ID,
                message_thread_id=thread_id,
                photo=photos[0],
                caption=ad_text,
                reply_markup=contact_kb,
            )
        else:
            sent_msg = await context.bot.send_message(
                chat_id=FORUM_CHAT_ID,
                message_thread_id=thread_id,
                text=ad_text,
                reply_markup=contact_kb,
            )
    except Exception as e:
        await update.effective_message.reply_text(f"ØªØ¹Ø°Ù‘Ø± Ø§Ù„Ù†Ø´Ø±: {e}")
        return ConversationHandler.END

    set_last_post_ts(user.id, int(time.time()))
    store_posted_ad(user.id, ad_hash)

    link_note = ""
    # Ù…Ù„Ø§Ø­Ø¸Ø©: ÙŠÙ„Ø²Ù… Ø§Ù„Ø¬Ø±ÙˆØ¨ ÙŠÙƒÙˆÙ† Ø¹Ø§Ù… ÙˆØ¨Ø§Ø³Ù… Ù…Ø³ØªØ®Ø¯Ù… FORUM_USERNAME ØµØ­ÙŠØ­
    if FORUM_USERNAME and sent_msg and sent_msg.message_id:
        link_note = f"\n\nØ±Ø§Ø¨Ø· Ø¥Ø¹Ù„Ø§Ù†Ùƒ: https://t.me/{FORUM_USERNAME}/{sent_msg.message_id}"

    await update.effective_message.reply_text("ØªÙ… Ù†Ø´Ø± Ø¥Ø¹Ù„Ø§Ù†Ùƒ Ø¨Ù†Ø¬Ø§Ø­ âœ…" + link_note, reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.effective_message.reply_text("ØªÙ… Ø§Ù„Ø¥Ù„ØºØ§Ø¡.", reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

# ============ App wiring ============
def build_app():
    app = ApplicationBuilder().token(BOT_TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("topicid", topicid))
    app.add_handler(CommandHandler("kill", kill))

    conv = ConversationHandler(
        entry_points=[
            CommandHandler("announce", announce_entry),
            MessageHandler(filters.Regex("^Ø¨Ø¯Ø¡ Ø¥Ø¹Ù„Ø§Ù† Ø¬Ø¯ÙŠØ¯$"), announce_entry)
        ],
        states={
            SECTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, set_section)],
            AGE: [
                CommandHandler("skip", skip_age),
                MessageHandler(filters.TEXT & ~filters.COMMAND, set_age)
            ],
            COUNT: [
                CommandHandler("skip", skip_count),
                MessageHandler(filters.TEXT & ~filters.COMMAND, set_count)
            ],
            PRICE: [
                CommandHandler("skip", skip_price),
                MessageHandler(filters.TEXT & ~filters.COMMAND, set_price)
            ],
            LOCATION: [
                CommandHandler("skip", skip_location),
                MessageHandler(filters.TEXT & ~filters.COMMAND, set_location)
            ],
            PHOTOS: [
                CommandHandler("skip", skip_photos),
                CommandHandler("done", done_photos),
                MessageHandler(filters.PHOTO, add_photo)
            ],
            CONTACT: [
                CommandHandler("skip", skip_contact),
                MessageHandler(filters.TEXT & ~filters.COMMAND, set_contact)
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        allow_reentry=True,
    )
    app.add_handler(conv)
    return app

async def runner_forever():
    db_init()
    backoff = 5
    while True:
        if not BOT_TOKEN:
            logger.error("BOT_TOKEN ØºÙŠØ± Ù…Ø¶Ø¨ÙˆØ· ÙÙŠ Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦Ø©.")
            await asyncio.sleep(60)
            continue

        app = build_app()
        app.bot_data["__STOP_FLAG__"] = False

        try:
            logger.info("ğŸš€ Starting pollingâ€¦")
            await app.run_polling(close_loop=False)
            if app.bot_data.get("__STOP_FLAG__"):
                logger.info("ğŸ›‘ Stopped by /kill.")
                break
            logger.warning("run_polling Ø§Ù†ØªÙ‡Øª Ø¨Ø¯ÙˆÙ† /kill. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¨Ø¹Ø¯ %s Ø«ÙˆØ§Ù†Ùâ€¦", backoff)
        except Exception as e:
            logger.exception("âŒ Exception in polling: %s", e)
        await asyncio.sleep(backoff)

if __name__ == "__main__":
    asyncio.run(runner_forever())
